use std::str::FromStr;
use crate::ast::*;
//use lalrpop_util::ParseError;

grammar;

pub Program : Program = {
    <e:Exp> => Program::Exp(e),
    <def:Def> => Program::Def(def),
}
pub Def : Def = {
    "node" "init" "[" <init:Exp> "]" <name:Id> "=" <val:Exp>  => Def::Node{name,init,val},
    "data" <name:Id> "=" <val:Exp> => Def::Data{name,val},
    "func" <name:Id> "(" <params:Comma<Id>> ")" "=" <body:Exp> => Def::Func{name,params,body}
}


Exp: Exp = {
    "if"  <cond:Exp>  "{" <then:Exp> "}" "else" "{" <els:Exp> "}" 
        => Exp::If{
            cond:Box::new(cond),
            then:Box::new(then),
            els:Box::new(els)},
    <e:Exp> "+" <t:Term> => Exp::Add(Box::new(e),Box::new(t)),
    
    "(" <e:Exp> ")" => e,
    <t:Term> => Exp::Term(Box::new(t))
};

Term : Term = {
    <t1:Term> "*" <t2:MonoTerm> => Term::Mul(Box::new(t1),Box::new(t2)),
    <t:MonoTerm> => t
}
MonoTerm : Term = {
    <name:Id> "(" <args:Comma<Exp>> ")" => Term::FnCall(Box::new(name),args),
    "true" => Term::Bool(true),
    "false" => Term::Bool(false),
    "0" => Term::Int(0),
    <i:r"[1-9][0-9]*"> => Term::Int(i32::from_str(i).unwrap()),
    <t:IdAtLast> => t,
    <id:Id> => Term::Id(id)
}
IdAtLast : Term = {
     <s:r"[a-z][a-z1-9]*@last"> => Term::Last(Id{s:(&s[0..s.len()-5]).to_string()})
}
Id : Id = {
    <s:r"[a-z][a-z1-9]*"> => Id{s:s.to_string()}
}
Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};